"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[484],{92546:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Instantiates a Catmull-Rom spline.","params":[{"name":"points","desc":"A list of points of the same type","lua_type":"{Vector2} | {Vector3} | {CFrame}"},{"name":"alpha","desc":"A number (usually in [0, 1]) that loosely affects the curvature of the spline at the control points (default: 0.5)","lua_type":"number?"},{"name":"tension","desc":"A number (usually in [0, 1]) that changes how taut the spline is (1 gives straight lines) (default: 0)","lua_type":"number?"},{"name":"loops","desc":"Whether the spline should form a smooth, closed loop","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"CatRom"}],"function_type":"static","tags":["Vector2","Vector3","CFrame"],"source":{"line":68,"path":"src/init.lua"}},{"name":"SolvePosition","desc":"Returns the position at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Essentials"],"source":{"line":150,"path":"src/init.lua"}},{"name":"SolveVelocity","desc":"Returns the velocity at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Essentials"],"source":{"line":166,"path":"src/init.lua"}},{"name":"SolveAcceleration","desc":"Returns the acceleration at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Essentials"],"source":{"line":182,"path":"src/init.lua"}},{"name":"SolveJerk","desc":"Returns the jerk at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Essentials"],"source":{"line":198,"path":"src/init.lua"}},{"name":"SolveTangent","desc":"Returns the unit tangent vector at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Essentials"],"source":{"line":214,"path":"src/init.lua"}},{"name":"SolveNormal","desc":"Returns the unit normal vector of the Frenet frame at time `t`. Returns\\n`(nan, nan, nan)` if the Frenet frame does not exist (i.e., when curvature\\nis 0).","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Essentials"],"source":{"line":232,"path":"src/init.lua"}},{"name":"SolveBinormal","desc":"Returns the unit binormal vector of the Frenet frame at time `t`. Returns\\n`(nan, nan, nan)` if the Frenet frame does not exist (i.e., when curvature\\nis 0).","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector3"}],"function_type":"method","tags":["Vector3","CFrame","Essentials"],"source":{"line":249,"path":"src/init.lua"}},{"name":"SolveCurvature","desc":"Returns the curvature at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Essentials"],"source":{"line":264,"path":"src/init.lua"}},{"name":"SolveTorsion","desc":"Returns the torsion at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Essentials"],"source":{"line":278,"path":"src/init.lua"}},{"name":"SolveCFrameLookAlong","desc":"Returns a CFrame at time `t` looking along the tangent vector of the spline\\nwith the goal up vector `upVector`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"},{"name":"upVector","desc":"The goal up vector (default: `Vector3.yAxis`)","lua_type":"Vector3?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"source":{"line":294,"path":"src/init.lua"}},{"name":"SolveCFrameFrenet","desc":"Returns a CFrame at time `t` with LookVector, UpVector, and RightVector\\nbeing the unit tangent, normal, and binormal vectors of the Frenet frame,\\nrespectively. Returns a CFrame with NaNs in its orientation if the Frenet\\nframe does not exist (i.e., when curvature is 0). The Frenet frame is also\\nprone to sudden twists when curvature is near 0.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"source":{"line":312,"path":"src/init.lua"}},{"name":"SolveCFrameSquad","desc":"Returns a CFrame at time `t` that smoothly interpolates the orientations of\\nthe control points using spherical quadrangle interpolation (SQUAD).","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["CFrame","Moving frames"],"source":{"line":326,"path":"src/init.lua"}},{"name":"SolveCFrameRMF","desc":"Returns an approximate rotation-minimizing frame (RMF), i.e., a CFrame that\\nhas minimal torsion when swept along the spline.\\n\\nIf you are tweening an RMF over time, then you can supply the RMF from the\\nprevious frame for a better approximation. Doing so also avoids calling\\n[CatRom:PrecomputeRMFs], which helps performance. Otherwise, if you do not\\nsupply a previous frame and you have not yet called [CatRom:PrecomputeRMFs],\\nthen [CatRom:PrecomputeRMFs] will be called for only the necessary\\ninterpolants.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"},{"name":"prevFrame","desc":"A previous, nearby RMF","lua_type":"CFrame?"},{"name":"numFramesPerSpline","desc":"The number of discrete approximations to pass to [CatRom:PrecomputeRMFs] if necessary (default: 4)","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"errors":[{"lua_type":"Bad input","desc":"prevFrame too close to queried frame"}],"source":{"line":355,"path":"src/init.lua"}},{"name":"GetParallelTransportInterpolant","desc":"Returns a function that sweeps a [Vector3] or [CFrame] along a spline with\\nminimal torsion.\\n\\nYou should call [CatRom:PrecomputeRMFs] beforehand if you want to control\\nthe accuracy of the rotation-minimizing frame approximation\u2014otherwise it\\nwill be called for you with default values.","params":[{"name":"data","desc":"The data to sweep","lua_type":"Vector3 | CFrame"},{"name":"from","desc":"The time to start at","lua_type":"number?"},{"name":"to","desc":"The time to end at","lua_type":"number?"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"A function that returns the transported data at a given time","lua_type":"(number) -> Vector3 | CFrame"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"source":{"line":396,"path":"src/init.lua"}},{"name":"GetNormalVectorInterpolant","desc":"Returns a function that interpolates the normal vectors `fromVector` and\\n`toVector` at times `from` and `to`, respectively. `fromVector` and\\n`toVector` are projected to ensure that they are normal to the spline.\\n\\nYou should call [CatRom:PrecomputeRMFs] beforehand if you want to control\\nthe accuracy of the rotation-minimizing frame approximation\u2014otherwise it\\nwill be called for you with default values.","params":[{"name":"from","desc":"","lua_type":"number"},{"name":"fromVector","desc":"","lua_type":"Vector3"},{"name":"to","desc":"","lua_type":"number"},{"name":"toVector","desc":"","lua_type":"Vector3"},{"name":"unitSpeed","desc":"","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"A function that returns the interpolated normal at a given time","lua_type":"(number) -> Vector3"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"errors":[{"lua_type":"Bad fromVector","desc":"fromVector cannot be tangent to the spline"},{"lua_type":"Bad toVector","desc":"toVector cannot be tangent to the spline"}],"source":{"line":442,"path":"src/init.lua"}},{"name":"PrecomputeRMFs","desc":"Precomputes a discrete approximation of a rotation-minimizing frame (RMF) along\\nthe spline.","params":[{"name":"numFramesPerSpline","desc":"The number of discrete approximations in each interpolant (default: 4)","lua_type":"number?"},{"name":"firstSplineIndex","desc":"The index of the first interpolant to compute RMFs on (default: 1)","lua_type":"number?"},{"name":"lastSplineIndex","desc":"The index of the last interpolant to compute RMFs on (default: #splines)","lua_type":"number?"}],"returns":[],"function_type":"method","tags":["Vector3","CFrame","Precomputes"],"source":{"line":497,"path":"src/init.lua"}},{"name":"GetSplineAtTime","desc":"In CatRom, a spline S is a piecewise function of n interpolants defined on\\nthe interval [0, 1]. We partition [0, 1] into n subintervals of the form\\n[k_i, k_{i+1}) where 0 = k1 < k2 < ... < kn < k_{n+1} = 1. The n+1 numbers\\nk1, ..., k_{n+1} are called \\"knots\\".\\n\\nThe i^th interpolant S_i is defined on the subinterval [k_i, k_{i+1}), where\\nthe width k_i - k_{i-1} is proportional to the arc length of S_i. That is,\\nk_i - k_{i-1} is the arc length of S_i divided by the total arc length of S.\\n\\nBelow is an example with n = 5. We can infer that S2 has a short arc length\\nwhile S4 has a long arc length.\\n\\nk1               k2     k3           k4                       k5         k6\\n|       S1       |  S2  |     S3     |           S4           |    S5    |\\n0 ---------------------------------------------------------------------- 1\\n\\nTo compute S(t), we find the subinterval [a, b) containing t and evaluate\\nits corresponding interpolant S_j at t. However, in implementation, S_j is\\nactually defined on [0, 1), so we first map [a, b) -> [0, 1). Hence\\nS(t) = S_j((t - a) / (b - a)). Finally, for completeness, S(1) = S_n(1) with\\nS_n having domain [0, 1] instead of [0, 1).","params":[{"name":"t","desc":"","lua_type":"number"}],"returns":[{"desc":"The interpolant S_j","lua_type":"Spline"},{"desc":"The time (t - a) / (b - a)","lua_type":"number"},{"desc":"The index j","lua_type":"number"}],"function_type":"method","tags":["Vector2","Vector3","CFrame"],"errors":[{"lua_type":"Failed to get spline","desc":"Should never happen"}],"source":{"line":551,"path":"src/init.lua"}},{"name":"PrecomputeUnitSpeedData","desc":"Makes `unitSpeed` methods significantly faster but slightly less accurate.\\nIt does this by approximating an expensive root-find on the arc length\\nfunction of an interpolant with a Chebyshev polynomial that interpolates the\\ninverse of the arc length function. Once the cheb has been computed, you can\\neither use it as a lookup table (\\"fast\\" strategy) or evaluate it as a\\npolynomial (\\"accurate\\" strategy). The \\"fast\\" strategy is roughly an order of\\nmagnitude faster than the \\"accurate\\" strategy but is less accurate.\\n\\t\\nYou should precompute when you are doing more `unitSpeed` calls per\\ninterpolant in the spline than the `degree` of the interpolant\'s cheb\\n(default: 8).","params":[{"name":"when","desc":"When the cheb should be computed: \\"now\\" is right now (useful for doing bulk solves immediately), \\"on demand\\" is as-needed (useful for doing bulk method calls over time)","lua_type":"\\"now\\" | \\"on demand\\"?"},{"name":"strategy","desc":"Whether the cheb gets used as a lookup table (\\"fast\\") or evaluated as a polynomial (\\"accurate\\")","lua_type":"\\"fast\\" | \\"accurate\\"?"},{"name":"degree","desc":"The degree of the chebyshev polynomial; higher is more accurate but slower (default: 8)","lua_type":"number?"}],"returns":[],"function_type":"method","tags":["Vector2","Vector3","CFrame","Precomputes"],"source":{"line":615,"path":"src/init.lua"}},{"name":"SolveLength","desc":"Computes the arc length of the spline between the times `from` and `to`.","params":[{"name":"from","desc":"The time to start at (default: 0)","lua_type":"number?"},{"name":"to","desc":"The time to end at (default: 1)","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","tags":["Vector2","Vector3","CFrame"],"source":{"line":641,"path":"src/init.lua"}},{"name":"SolveBulk","desc":"A helper method for doing the same computation at many uniformly-spaced\\ntimes. Has better performance than writing a for loop manually.","params":[{"name":"f","desc":"A function accepting an interpolant and a time","lua_type":"(Spline, number) -> ()"},{"name":"numSamples","desc":"The number of uniformly-spaced samples (includes the two samples at the boundaries)","lua_type":"number"},{"name":"from","desc":"The time to start at (default: 0)","lua_type":"number?"},{"name":"to","desc":"The time to end at (default: 1)","lua_type":"number?"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?\\r\\n"}],"returns":[],"function_type":"method","tags":["Vector2","Vector3","CFrame"],"source":{"line":683,"path":"src/init.lua"}},{"name":"SolveBoundingBox","desc":"Returns an axis-aligned box that bounds the spline.","params":[],"returns":[{"desc":"The minimum corner","lua_type":"Vector"},{"desc":"The maximum corner","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame"],"source":{"line":752,"path":"src/init.lua"}},{"name":"CreateTween","desc":"A wrapper around TweenService that executes a callback function. The\\ncallback accepts an interpolant and a time to pass into the interpolant\'s\\nmethods. You must manually assign instance properties yourself.\\n\\n```lua\\n-- Tweens a part\'s CFrame from time 0 to time 1 with unit speed\\nlocal part = Instance.new(\\"Part\\", workspace)\\nlocal spline = CatRom.new({...})\\n\\nlocal tweenInfo = TweenInfo.new()\\nlocal callback = function(spline, t)\\n\\tpart.CFrame = spline:SolveCFrameRMF(t)\\nend\\n\\nlocal tween = spline:CreateTween(tweenInfo, callback, 0, 1, true)\\ntween:Play()\\n```","params":[{"name":"tweenInfo","desc":"","lua_type":"TweenInfo"},{"name":"callback","desc":"","lua_type":"(Types.Spline, number) -> ()"},{"name":"from","desc":"","lua_type":"number?"},{"name":"to","desc":"","lua_type":"number?"},{"name":"unitSpeed","desc":"","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"","lua_type":"Tween\\r\\n"}],"function_type":"method","source":{"line":789,"path":"src/init.lua"}}],"properties":[{"name":"knots","desc":"The knot vector of the spline.\\r","lua_type":"{number}","private":true,"source":{"line":23,"path":"src/init.lua"}},{"name":"length","desc":"The arc length of the spline.\\r","lua_type":"number","source":{"line":27,"path":"src/init.lua"}},{"name":"points","desc":"The control points of the spline. This table will not necessarily match the\\ntable of control points passed into the constructor, as adjacent points\\nthat are fuzzy-equal are removed during construction.\\r","lua_type":"{Point}","source":{"line":33,"path":"src/init.lua"}},{"name":"splines","desc":"The individual interpolants chained together to build the full spline.\\r","lua_type":"{Spline}","source":{"line":37,"path":"src/init.lua"}}],"types":[{"name":"Vector","desc":"","lua_type":"Vector2 | Vector3","source":{"line":18,"path":"src/init.lua"}}],"name":"CatRom","desc":"A Catmull-Rom spline.\\r","source":{"line":13,"path":"src/init.lua"}}')}}]);