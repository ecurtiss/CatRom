"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[484],{92546:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Instantiates a [CatRom].","params":[{"name":"points","desc":"A list of points of the same type","lua_type":"{Vector2} | {Vector3} | {CFrame}"},{"name":"alpha","desc":"A number (usually in [0, 1]) that loosely affects the curvature of the spline at the control points (default: 0.5)","lua_type":"number?"},{"name":"tension","desc":"A number (usually in [0, 1]) that changes how taut the spline is (1 gives straight lines) (default: 0)","lua_type":"number?"},{"name":"loops","desc":"Whether the spline should form a smooth, closed loop","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"CatRom"}],"function_type":"static","tags":["Vector2","Vector3","CFrame"],"source":{"line":81,"path":"src/init.lua"}},{"name":"SolvePosition","desc":"Returns the position at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":163,"path":"src/init.lua"}},{"name":"SolveVelocity","desc":"Returns the velocity at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":179,"path":"src/init.lua"}},{"name":"SolveAcceleration","desc":"Returns the acceleration at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":195,"path":"src/init.lua"}},{"name":"SolveJerk","desc":"Returns the jerk at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":210,"path":"src/init.lua"}},{"name":"SolveTangent","desc":"Returns the unit tangent vector at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":225,"path":"src/init.lua"}},{"name":"SolveNormal","desc":"Returns the unit normal vector of the Frenet frame at time `t`. Returns\\n`(nan, nan, nan)` if the Frenet frame does not exist (i.e., when curvature\\nis 0).","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":243,"path":"src/init.lua"}},{"name":"SolveBinormal","desc":"Returns the unit binormal vector of the Frenet frame at time `t`. Returns\\n`(nan, nan, nan)` if the Frenet frame does not exist (i.e., when curvature\\nis 0).","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"Vector3"}],"function_type":"method","tags":["Vector3","CFrame","Basics"],"source":{"line":260,"path":"src/init.lua"}},{"name":"SolveCurvature","desc":"Returns the curvature at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":275,"path":"src/init.lua"}},{"name":"SolveTorsion","desc":"Returns the torsion at time `t`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Basics"],"source":{"line":289,"path":"src/init.lua"}},{"name":"SolveCFrameLookAlong","desc":"Returns a CFrame at time `t` looking along the tangent vector of the spline\\nwith the goal up vector `upVector`.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"},{"name":"upVector","desc":"The goal up vector (default: `Vector3.yAxis`)","lua_type":"Vector3?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"source":{"line":305,"path":"src/init.lua"}},{"name":"SolveCFrameFrenet","desc":"Returns a CFrame at time `t` with LookVector, UpVector, and RightVector\\nbeing the unit tangent, normal, and binormal vectors of the Frenet frame,\\nrespectively. Returns a CFrame with NaNs in its orientation if the Frenet\\nframe does not exist (i.e., when curvature is 0). The Frenet frame is also\\nprone to sudden twists when curvature is near 0.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"source":{"line":323,"path":"src/init.lua"}},{"name":"SolveCFrameSquad","desc":"Returns a CFrame at time `t` that smoothly interpolates the orientations of\\nthe control points using spherical quadrangle interpolation (SQUAD).","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["CFrame","Moving frames"],"source":{"line":337,"path":"src/init.lua"}},{"name":"SolveCFrameRMF","desc":"Returns an approximate rotation-minimizing frame (RMF), i.e., a CFrame that\\nhas minimal torsion when swept along the spline. This method is not useful\\non its own, but it underlies the more powerful [CatRom:Transport] and\\n[CatRom:SlerpNormals] (and their bulk alternatives\\n[CatRom:GetTransportInterpolant] and [CatRom:GetSlerpNormalsInterpolant]).\\n\\nIf you are tweening an RMF over time, then you can supply the RMF from the\\nprevious point in time for a better approximation. Doing so also avoids\\ncalling [CatRom:PrecomputeRMFs], which helps performance. Otherwise, if you\\ndo not supply a previous frame and you have not yet called\\n[CatRom:PrecomputeRMFs], then [CatRom:PrecomputeRMFs] will be called for\\nonly the necessary segments.","params":[{"name":"t","desc":"Time","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?"},{"name":"prevFrame","desc":"A previous, nearby RMF","lua_type":"CFrame?"},{"name":"numFramesPerSegment","desc":"The number of discrete approximations to pass to [CatRom:PrecomputeRMFs] if necessary (default: 4)","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"CFrame\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Moving frames"],"source":{"line":368,"path":"src/init.lua"}},{"name":"Transport","desc":"Sweeps a [Vector3] or [CFrame] along the spline such that the result has\\nbeen twisted minimally around the spline.\\n\\nYou should call [CatRom:PrecomputeRMFs] beforehand if you want to control\\nthe accuracy of the approximation\u2014otherwise it will be called for you with\\ndefault values.\\n\\n:::tip\\nSee [CatRom:GetTransportInterpolant] if you intend to use this method in\\nbulk.\\n:::","params":[{"name":"data","desc":"The data to sweep","lua_type":"Vector3 | CFrame"},{"name":"from","desc":"The time where the data comes from","lua_type":"number?"},{"name":"to","desc":"The time to sweep to","lua_type":"number?"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"","lua_type":"Vector3 | CFrame\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Extensions"],"source":{"line":413,"path":"src/init.lua"}},{"name":"GetTransportInterpolant","desc":"Returns a function that sweeps a [Vector3] or [CFrame] along the spline with\\nminimal torsion. You should use this method instead of [CatRom:Transport] if\\nyou are doing transports in bulk, as the interpolant saves on CFrame\\nmultiplies.\\n\\nYou should call [CatRom:PrecomputeRMFs] beforehand if you want to control\\nthe accuracy of approximation\u2014otherwise it will be called for you with\\ndefault values.","params":[{"name":"data","desc":"The data to sweep","lua_type":"Vector3 | CFrame"},{"name":"from","desc":"The time where the data comes from","lua_type":"number?"},{"name":"to","desc":"The time to sweep to","lua_type":"number?"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"A function that returns the transported data at a given time","lua_type":"(number) -> Vector3 | CFrame"}],"function_type":"method","tags":["Vector3","CFrame","Extensions"],"source":{"line":456,"path":"src/init.lua"}},{"name":"SlerpNormals","desc":"Slerps the normal vectors `fromVector` and `toVector` at times `from` and\\n`to`, respectively, with progress `t` in [0, 1]. `fromVector` and `toVector`\\nare projected to ensure that they are normal to the spline.\\n\\nYou should call [CatRom:PrecomputeRMFs] beforehand if you want to control\\nthe accuracy of the approximation\u2014otherwise it will be called for you with\\ndefault values.\\n\\n:::tip\\nTry [CatRom:GetSlerpNormalsInterpolant] if you intend to use this method in\\nbulk.\\n:::","params":[{"name":"from","desc":"Time","lua_type":"number"},{"name":"fromVector","desc":"A vector that is normal to the spline at time `from`","lua_type":"Vector3"},{"name":"to","desc":"Time","lua_type":"number"},{"name":"toVector","desc":"A vector that is normal to the spline at time `to`","lua_type":"Vector3"},{"name":"t","desc":"The progress of the slerp from `fromVector` to `toVector` in [0, 1]","lua_type":"number"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"","lua_type":"Vector3\\r\\n"}],"function_type":"method","tags":["Vector3","CFrame","Extensions"],"errors":[{"lua_type":"Bad fromVector","desc":"fromVector cannot be tangent to the spline"},{"lua_type":"Bad toVector","desc":"toVector cannot be tangent to the spline"}],"source":{"line":548,"path":"src/init.lua"}},{"name":"GetSlerpNormalsInterpolant","desc":"Returns a function that interpolates the normal vectors `fromVector` and\\n`toVector` at times `from` and `to`, respectively. `fromVector` and\\n`toVector` are projected to ensure that they are normal to the spline.\\nYou should use this method instead of [CatRom:SlerpNormals] if you are\\ndoing slerps in bulk, as the interpolant saves on Vector operations.\\n\\nYou should call [CatRom:PrecomputeRMFs] beforehand if you want to control\\nthe accuracy of the approximation\u2014otherwise it will be called for you with\\ndefault values.","params":[{"name":"from","desc":"Time","lua_type":"number"},{"name":"fromVector","desc":"A vector that is normal to the spline at time `from`","lua_type":"Vector3"},{"name":"to","desc":"Time","lua_type":"number"},{"name":"toVector","desc":"A vector that is normal to the spline at time `to`","lua_type":"Vector3"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"A function that returns the interpolated normal at a given time","lua_type":"(number) -> Vector3"}],"function_type":"method","tags":["Vector3","CFrame","Extensions"],"errors":[{"lua_type":"Bad fromVector","desc":"fromVector cannot be tangent to the spline"},{"lua_type":"Bad toVector","desc":"toVector cannot be tangent to the spline"}],"source":{"line":591,"path":"src/init.lua"}},{"name":"PrecomputeRMFs","desc":"Precomputes a discrete approximation of a moving rotation-minimizing frame\\n(RMF) along the spline.","params":[{"name":"numFramesPerSegment","desc":"The number of discrete approximations in each segment (default: 4)","lua_type":"number?"},{"name":"firstSegmentIndex","desc":"The index of the first segment to compute RMFs on (default: 1)","lua_type":"number?"},{"name":"lastSegmentIndex","desc":"The index of the last segment to compute RMFs on (default: #segments)","lua_type":"number?"}],"returns":[],"function_type":"method","tags":["Vector3","CFrame","Precomputes"],"source":{"line":622,"path":"src/init.lua"}},{"name":"GetSegmentAtTime","desc":"In CatRom, a spline S is a piecewise function of n interpolants defined on\\nthe interval [0, 1]. We partition [0, 1] into n subintervals of the form\\n[k_i, k_{i+1}) where 0 = k1 < k2 < ... < kn < k_{n+1} = 1. The n+1 numbers\\nk1, ..., k_{n+1} are called \\"knots\\".\\n\\nThe i^th interpolant S_i is defined on the subinterval [k_i, k_{i+1}), where\\nthe width k_i - k_{i-1} is proportional to the arc length of S_i. That is,\\nk_i - k_{i-1} is the arc length of S_i divided by the total arc length of S.\\n\\nBelow is an example with n = 5. We can infer that S2 has a short arc length\\nwhile S4 has a long arc length.\\n\\nk1               k2     k3           k4                       k5         k6\\n|       S1       |  S2  |     S3     |           S4           |    S5    |\\n0 ---------------------------------------------------------------------- 1\\n\\nTo compute S(t), we find the subinterval [a, b) containing t and evaluate\\nits corresponding interpolant S_j at t. However, in implementation, S_j is\\nactually defined on [0, 1), so we first map [a, b) -> [0, 1). Hence\\nS(t) = S_j((t - a) / (b - a)). Finally, for completeness, S(1) = S_n(1) with\\nS_n having domain [0, 1] instead of [0, 1).","params":[{"name":"t","desc":"","lua_type":"number"}],"returns":[{"desc":"The interpolant S_j","lua_type":"Segment"},{"desc":"The time (t - a) / (b - a)","lua_type":"number"},{"desc":"The index j","lua_type":"number"}],"function_type":"method","tags":["Vector2","Vector3","CFrame"],"errors":[{"lua_type":"Failed to get segment","desc":"Should never happen"}],"source":{"line":677,"path":"src/init.lua"}},{"name":"PrecomputeUnitSpeedData","desc":"Makes `unitSpeed` methods significantly faster but slightly less accurate.\\nIt does this by approximating an expensive root-find on the arc length\\nfunction of a segment with a Chebyshev polynomial that interpolates the\\ninverse of the arc length function. Once the cheb has been computed, you can\\neither use it as a lookup table (\\"fast\\" strategy) or evaluate it as a\\npolynomial (\\"accurate\\" strategy). The \\"fast\\" strategy is roughly an order of\\nmagnitude faster than the \\"accurate\\" strategy but is less accurate.\\n\\t\\nYou should precompute when you are doing more `unitSpeed` calls per\\nsegment in the spline than the `degree` of the segment\'s cheb\\n(default: 8).","params":[{"name":"when","desc":"When the cheb should be computed: \\"now\\" is right now (useful for doing bulk solves immediately), \\"on demand\\" is as-needed (useful for doing bulk method calls over time)","lua_type":"\\"now\\" | \\"on demand\\"?"},{"name":"strategy","desc":"Whether the cheb gets used as a lookup table (\\"fast\\") or evaluated as a polynomial (\\"accurate\\")","lua_type":"\\"fast\\" | \\"accurate\\"?"},{"name":"degree","desc":"The degree of the chebyshev polynomial; higher is more accurate but slower (default: 8)","lua_type":"number?"}],"returns":[],"function_type":"method","tags":["Vector2","Vector3","CFrame","Precomputes"],"source":{"line":741,"path":"src/init.lua"}},{"name":"SolveLength","desc":"Computes the arc length of the spline between the times `from` and `to`.","params":[{"name":"from","desc":"The time to start at (default: 0)","lua_type":"number?"},{"name":"to","desc":"The time to end at (default: 1)","lua_type":"number?"}],"returns":[{"desc":"","lua_type":"number\\r\\n"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Basics"],"source":{"line":768,"path":"src/init.lua"}},{"name":"SolveBulk","desc":"A helper method for doing the same computation at many uniformly-spaced\\ntimes. Has better performance than writing a for loop manually.","params":[{"name":"f","desc":"A function accepting a segment and a time","lua_type":"(Segment, number) -> ()"},{"name":"numSamples","desc":"The number of uniformly-spaced samples (includes the two samples at the boundaries)","lua_type":"number"},{"name":"from","desc":"The time to start at (default: 0)","lua_type":"number?"},{"name":"to","desc":"The time to end at (default: 1)","lua_type":"number?"},{"name":"unitSpeed","desc":"Whether the spline has unit speed (default: `false`)","lua_type":"boolean?\\r\\n"}],"returns":[],"function_type":"method","tags":["Vector2","Vector3","CFrame","Extensions"],"source":{"line":811,"path":"src/init.lua"}},{"name":"SolveBoundingBox","desc":"Returns an axis-aligned box that bounds the spline.","params":[],"returns":[{"desc":"The minimum corner","lua_type":"Vector"},{"desc":"The maximum corner","lua_type":"Vector"}],"function_type":"method","tags":["Vector2","Vector3","CFrame"],"source":{"line":880,"path":"src/init.lua"}},{"name":"CreateTween","desc":"A wrapper around TweenService that executes a callback function. The\\ncallback accepts a segment and a time to pass into the segment\'s\\nmethods. You must manually assign instance properties yourself.\\n\\n```lua\\n-- Tweens a part\'s CFrame from time 0 to time 1 with unit speed\\nlocal part = Instance.new(\\"Part\\", workspace)\\nlocal spline = CatRom.new({...})\\n\\nlocal tweenInfo = TweenInfo.new()\\nlocal callback = function(segment, t)\\n\\tpart.CFrame = segment:SolveCFrameRMF(t)\\nend\\n\\nlocal tween = spline:CreateTween(tweenInfo, callback, 0, 1, true)\\ntween:Play()\\n```","params":[{"name":"tweenInfo","desc":"","lua_type":"TweenInfo"},{"name":"callback","desc":"","lua_type":"(Types.Segment, number) -> ()"},{"name":"from","desc":"","lua_type":"number?"},{"name":"to","desc":"","lua_type":"number?"},{"name":"unitSpeed","desc":"","lua_type":"boolean?\\r\\n"}],"returns":[{"desc":"","lua_type":"Tween\\r\\n"}],"function_type":"method","tags":["Vector2","Vector3","CFrame","Extensions"],"source":{"line":922,"path":"src/init.lua"}}],"properties":[{"name":"knots","desc":"The knot vector of the spline.\\r","lua_type":"{number}","private":true,"source":{"line":36,"path":"src/init.lua"}},{"name":"length","desc":"The arc length of the spline.\\r","lua_type":"number","source":{"line":40,"path":"src/init.lua"}},{"name":"points","desc":"The control points of the spline. This table will not necessarily match the\\ntable of control points passed into the constructor, as adjacent points\\nthat are fuzzy-equal are removed during construction.\\r","lua_type":"{Point}","source":{"line":46,"path":"src/init.lua"}},{"name":"segments","desc":"The chain of interpolating segments that make up the full spline.\\r","lua_type":"{Segment}","source":{"line":50,"path":"src/init.lua"}}],"types":[{"name":"Vector","desc":"","lua_type":"Vector2 | Vector3","source":{"line":31,"path":"src/init.lua"}}],"name":"CatRom","desc":"A Catmull-Rom spline.\\n\\n:::note\\nThe `Vector2`, `Vector3`, and `CFrame` tags indicate whether a method is\\ndefined for the type of control points used to create the [CatRom].\\n:::\\n:::tip\\nYou should call [CatRom:PrecomputeUnitSpeedData] immediately after\\nconstruction if you intend to do many computations with `unitSpeed` true\\n(where \\"many\\" is roughly 8 per segment). Doing so will drastically improve\\nthe performance of reparametrizations with a small loss to accuracy.\\n:::","source":{"line":26,"path":"src/init.lua"}}')}}]);